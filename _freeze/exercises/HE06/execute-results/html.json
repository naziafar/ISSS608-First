{
  "hash": "41852ec32a7a3243745555bc4cbc5258",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exercise 6\"\nsubtitle: \"Visualising and Analysing Time-oriented Data\"\nauthor: \"Nazia Faruqui\"\ndate: 2026-02-25\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n# 1. Overview\n\nBy the end of this hands-on exercise, we will be able create the followings data visualisation by using R packages:\n\n-   calender heatmap using ggplot2 functions,\n\n-   cycle plot using ggplot2 function,\n\n-   slopegraph\n\n# 2. Installing and loading R packages\n\nWe will use the code chunk below to install and launch **scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table, CGPfunctions, ggHoriPlot** and **tidyverse** in RStudio.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(scales, viridis, lubridate, ggthemes,\n               gridExtra, readxl, knitr, data.table,\n               CGPfunctions, ggHoriPlot, tidyverse)\n```\n:::\n\n\nFor the newer versions of R, the CGPfunctions package would need to be installed by downloading it from git using the code below, as the package has been removed from the CRAN repository. Its dependency 'ggmosaic' would first need to be installed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_git(\"https://github.com/haleyjeppson/ggmosaic\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_git(\"https://github.com/ibecav/CGPfunctions\")\n```\n:::\n\n\n# 3. Plotting Calendar Heatmaps\n\nIn this section, we will learn how to plot a calender heatmap programmatically by using ggplot2 package.\n\nBy the end of this section, we will be able to:\n\n-   plot a calender heatmap by using ggplot2 functions and extension,\n\n-   to write function using R programming,\n\n-   to derive specific date and time related field by using base R and lubridate packages\n\n-   to perform data preparation task by using tidyr and dplyr packages.\n\n## 3.1 Importing and examining the dataset\n\n::: panel-tabset\n### Importing Data\n\nFor the purpose of this hands-on exercise, *eventlog.csv* file will be used. This data file consists of 199,999 rows of time-series cyber attack records by country.\n\nWe will use the code chunk below to import *eventlog.csv* file into R environment and called the data frame as *attacks*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks <- read_csv(\"../data/eventlog.csv\")\n```\n:::\n\n\n### Examining the data structure\n\nIt is always a good practice to examine the imported data frame before performing further analysis.\n\nBelow, we use *kable()* to review the structure of the imported data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|timestamp           |source_country |tz              |\n|:-------------------|:--------------|:---------------|\n|2015-03-12 15:59:16 |CN             |Asia/Shanghai   |\n|2015-03-12 16:00:48 |FR             |Europe/Paris    |\n|2015-03-12 16:02:26 |CN             |Asia/Shanghai   |\n|2015-03-12 16:02:38 |US             |America/Chicago |\n|2015-03-12 16:03:22 |CN             |Asia/Shanghai   |\n|2015-03-12 16:03:45 |CN             |Asia/Shanghai   |\n\n\n:::\n:::\n\n\nThere are three columns, namely *timestamp*, *source_country* and *tz*.\n\n-   *timestamp* field stores date-time values in POSIXct format.\n\n-   *source_country* field stores the source of the attack. It is in *ISO 3166-1 alpha-2* country code.\n\n-   *tz* field stores time zone of the source IP address.\n:::\n\n## 3.2 Data Preparation\n\n**Step 1: Deriving *weekday* and *hour of day* fields**\n\nBefore we can plot the calender heatmap, two new fields namely *wkday* and *hour* need to be derived. In this step, we will write a function to perform this task.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_hr_wkday <- function(ts, sc, tz) {\n  real_times <- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n```\n:::\n\n\n::: callout-note\n-   [`ymd_hms()`](https://lubridate.tidyverse.org/reference/ymd_hms.html) and [`hour()`](https://lubridate.tidyverse.org/reference/hour.html) are from [**lubridate**](https://lubridate.tidyverse.org/) package, and\n\n-   [`weekdays()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/weekdays) is a **base** R function.\n:::\n\n**Step 2: Deriving the attacks tibble data frame**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks %>%\n  group_by(tz) %>%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %>% \n  ungroup() %>% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n```\n:::\n\n\n::: callout-note\nBeside extracting the necessary data into *attacks* data frame, `mutate()` of **dplyr** package is used to convert *wkday* and *hour* fields into **factor** so they’ll be ordered when plotting.\n:::\n\nThe table below shows the tidy tibble table after processing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n\n\n|tz           |source_country |wkday    |hour |\n|:------------|:--------------|:--------|:----|\n|Africa/Cairo |BG             |Saturday |20   |\n|Africa/Cairo |TW             |Sunday   |6    |\n|Africa/Cairo |TW             |Sunday   |8    |\n|Africa/Cairo |CN             |Sunday   |11   |\n|Africa/Cairo |US             |Sunday   |15   |\n|Africa/Cairo |CA             |Monday   |11   |\n\n\n:::\n:::\n\n\n## 3.3 Building the calendar heatmaps\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngrouped <- attacks %>% \n  count(wkday, hour) %>% \n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](HE06_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=1248}\n:::\n:::\n\n\n::: callout-important\n## Things to learn from the code chunk above\n\n-   a tibble data table called *grouped* is derived by aggregating the attack by *wkday* and *hour* fields.\n\n-   a new field called *n* is derived by using `group_by()` and `count()` functions.\n\n-   `na.omit()` is used to exclude missing value.\n\n-   `geom_tile()` is used to plot tiles (grids) at each x and y position. `color` and `size` arguments are used to specify the border color and line size of the tiles.\n\n-   [`theme_tufte()`](https://jrnold.github.io/ggthemes/reference/theme_tufte.html) of [**ggthemes**](https://jrnold.github.io/ggthemes/reference/index.html) package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.\n\n-   `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1.\n\n-   `scale_fill_gradient()` function is used to creates a two colour gradient (low-high).\n:::\n\nThen we can simply group the count by hour and wkday and plot it, since we know that we have values for every combination there’s no need to further preprocess the data.\n\n## 3.4 Plotting multiple calendar heatmaps\n\nTask: Building multiple heatmaps for the top four countries with the highest number of attacks.\n\n**Step 1: Deriving attack by country object**\n\nIn order to identify the top 4 countries with the highest number of attacks, we need to do the following:\n\n-   count the number of attacks by country,\n\n-   calculate the percent of attacks by country, and\n\n-   save the results in a tibble data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks_by_country <- count(\n  attacks, source_country) %>%\n  mutate(percent = percent(n/sum(n))) %>%\n  arrange(desc(n))\n```\n:::\n\n\n**Step 2: Preparing the tidy data frame**\n\nIn this step, we need to extract the attack records of the top 4 countries from *attacks* data frame and save the data in a new tibble data frame (i.e. *top4_attacks*).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop4 <- attacks_by_country$source_country[1:4]\ntop4_attacks <- attacks %>%\n  filter(source_country %in% top4) %>%\n  count(source_country, wkday, hour) %>%\n  ungroup() %>%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %>%\n  na.omit()\n```\n:::\n\n\n**Step 3: Plotting the Multiple Calender Heatmap by using ggplot2 package**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](HE06_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=1248}\n:::\n:::\n\n\n# 4. Plotting Cycle Plot\n\nIn this section,we will learn how to plot a cycle plot showing the time-series patterns and trend of visitor arrivals from Vietnam programmatically by using ggplot2 functions.\n\n**Step 1: Data Import**\n\nWe will be using a different data set for this part of the exercise called *arrivals_by_air.xlsx*\n\nThe code chunk below imports *arrivals_by_air.xlsx* by using `read_excel()` of **readxl** package and saves it as a tibble data frame called *air*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair <- read_excel(\"../data/arrivals_by_air.xlsx\")\n```\n:::\n\n\n**Step 2: Deriving month and year fields**\n\nNext, two new fields called *month* and *year* are derived from the *Month-Year* field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair$month <- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year <- year(ymd(air$`Month-Year`))\n```\n:::\n\n\n**Step 3: Extracting the target country**\n\nNext, the code chunk below is use to extract data for the target country, Vietnam.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVietnam <- air %>% \n  select(`Vietnam`, \n         month, \n         year) %>%\n  filter(year >= 2010)\n```\n:::\n\n\n**Step 4: Computing year average arrivals by month**\n\nThe code chunk below uses `group_by()` and `summarise()` of **dplyr** to compute year average arrivals by month.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhline.data <- Vietnam %>% \n  group_by(month) %>%\n  summarise(avgvalue = mean(`Vietnam`))\n```\n:::\n\n\n**Step 5: Plotting the cycle plot**\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_tufte(base_family = \"Helvetica\")\n```\n\n::: {.cell-output-display}\n![](HE06_files/figure-html/unnamed-chunk-17-1.png){fig-align='center' width=1248}\n:::\n:::\n\n\n# 5. Plotting Slopegraph\n\nIn this section we will learn how to plot a [slopegraph](https://www.storytellingwithdata.com/blog/2020/7/27/what-is-a-slopegraph) by using R.\n\nWe will be using the **CGPfunctions** package for this part, so we need to ensure that it has been installed and loaded onto the R environment. To learn more about the `newggslopegraph()` function and its arguments, refer to this [link](https://www.rdocumentation.org/packages/CGPfunctions/versions/0.6.3/topics/newggslopegraph).\n\n**Step 1: Data Import**\n\nImport the rice data set into R environment by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice <- read_csv(\"../data/rice.csv\")\n```\n:::\n\n\n**Step 2: Plotting the slopegraph**\n\nThe code chunk below will be used to plot a basic slopegraph as shown below.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(1961, 1980)) %>%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Countries\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Nazia Faruqui\n                Code from: Dr. Kam Tin Seong\")\n```\n\n::: {.cell-output-display}\n![](HE06_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=1248}\n:::\n:::\n\n\n::: callout-important\n## Things to learn from the code chunk above\n\nFor effective data visualisation design, `factor()` is used convert the value type of *Year* field from numeric to factor.\n:::\n\n# 6. Reference\n\n-   Kam, T.S. (2023). [Visualising and Analysing Time-oriented Data](https://r4va.netlify.app/chap17).\n",
    "supporting": [
      "HE06_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}